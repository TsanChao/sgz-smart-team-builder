# 协同分析引擎设计方案

## 一、设计理念

遵循系统设计的最佳实践，保持数据层的纯净性，通过独立的分析引擎从基础数据中提取和计算协同信息，而不是在底层数据结构中直接存储协同关系。

## 二、引擎架构

### 2.1 核心模块组成

```
协同分析引擎 (SynergyAnalyzer)
├── 文本解析模块 (TextParser)
├── 关键词识别模块 (KeywordRecognizer)
├── 条件效果分析模块 (ConditionEffectAnalyzer)
├── 协同关系识别模块 (SynergyRelationRecognizer)
├── 协同强度计算模块 (SynergyStrengthCalculator)
├── 队伍协同分析模块 (TeamSynergyAnalyzer)
├── 规则配置模块 (RuleConfigurator)
└── 结果输出模块 (ResultOutputter)
```

### 2.2 模块职责

#### 2.2.1 文本解析模块 (TextParser)
- 解析战法描述文本
- 识别句子结构和语义关系
- 提取关键信息片段

#### 2.2.2 关键词识别模块 (KeywordRecognizer)
- 维护关键词词典
- 识别效果类型关键词
- 标准化效果描述

#### 2.2.3 条件效果分析模块 (ConditionEffectAnalyzer)
- 识别条件-效果关系
- 分析触发条件和实际效果
- 建立效果间的逻辑关系

#### 2.2.4 协同关系识别模块 (SynergyRelationRecognizer)
- 基于条件-效果关系识别协同关系
- 分类协同类型（控制+输出、状态+输出等）
- 评估协同潜力

#### 2.2.5 协同强度计算模块 (SynergyStrengthCalculator)
- 计算协同强度值
- 考虑效果范围、触发概率等因素
- 输出量化的协同评分

#### 2.2.6 队伍协同分析模块 (TeamSynergyAnalyzer)
- 分析整个队伍的协同效应
- 评估队伍角色完整性
- 计算队伍整体协同评分

#### 2.2.7 规则配置模块 (RuleConfigurator)
- 管理协同规则配置
- 支持规则动态调整
- 提供规则扩展接口

#### 2.2.8 结果输出模块 (ResultOutputter)
- 结构化输出分析结果
- 生成详细分析报告
- 提供改进建议

## 三、核心功能实现

### 3.1 文本解析模块

#### 3.1.1 功能描述
从战法描述中提取结构化信息，包括：
- 效果类型：控制、输出、治疗、增益、减益等
- 效果条件：前提条件、触发条件
- 效果结果：实际产生的效果
- 目标类型：单体、群体、全体等
- 效果范围：影响的武将数量
- 触发概率：效果发动的概率

#### 3.1.2 实现方法
```python
class TextParser:
    def parse_skill_description(self, description):
        # 解析描述文本，提取关键信息
        effects = []
        sentences = self.split_sentences(description)
        for sentence in sentences:
            effect = self.extract_effect_info(sentence)
            if effect:
                effects.append(effect)
        return effects
    
    def extract_effect_info(self, sentence):
        # 从单句中提取效果信息
        effect = {
            "type": self.identify_effect_type(sentence),
            "condition": self.extract_condition(sentence),
            "result": self.extract_result(sentence),
            "target": self.identify_target_type(sentence),
            "scope": self.identify_effect_scope(sentence),
            "probability": self.extract_probability(sentence)
        }
        return effect
```

### 3.2 关键词识别模块

#### 3.2.1 关键词词典
```json
{
  "控制类": ["缴械", "震慑", "计穷", "混乱", "伪报", "禁疗"],
  "状态类": ["灼烧", "中毒", "溃逃", "沙暴", "水攻", "叛逃"],
  "增益类": ["攻心", "急救", "奇谋", "先攻", "必攻", "破阵"],
  "减益类": ["虚弱", "遇袭", "破坏", "叛变"],
  "输出类": ["伤害", "攻击", "决斗", "火攻", "水攻"],
  "治疗类": ["恢复", "治疗", "急救", "兵力"],
  "辅助类": ["免疫", "转移", "净化", "驱散"]
}
```

#### 3.2.2 实现方法
```python
class KeywordRecognizer:
    def __init__(self):
        self.keyword_dict = self.load_keyword_dictionary()
    
    def identify_effect_type(self, text):
        # 根据关键词识别效果类型
        for effect_type, keywords in self.keyword_dict.items():
            for keyword in keywords:
                if keyword in text:
                    return effect_type
        return "未知"
    
    def extract_keywords(self, text):
        # 提取文本中的所有关键词
        keywords = []
        for effect_type, keyword_list in self.keyword_dict.items():
            for keyword in keyword_list:
                if keyword in text:
                    keywords.append({
                        "keyword": keyword,
                        "type": effect_type
                    })
        return keywords
```

### 3.3 条件效果分析模块

#### 3.3.1 功能描述
识别战法描述中的条件-效果关系，例如：
- "若目标处于缴械或计穷状态，则额外使目标统率降低" 
  - 条件：目标处于缴械或计穷状态
  - 效果：使目标统率降低

#### 3.3.2 实现方法
```python
class ConditionEffectAnalyzer:
    def analyze_condition_effect(self, description):
        # 分析条件-效果关系
        relations = []
        
        # 识别条件关键词
        condition_patterns = ["若", "如果", "当", "处于", "已有"]
        effect_patterns = ["则", "额外", "并且", "同时"]
        
        # 提取条件和效果部分
        condition_part, effect_part = self.split_condition_effect(description)
        
        if condition_part and effect_part:
            relation = {
                "condition": self.parse_condition(condition_part),
                "effect": self.parse_effect(effect_part),
                "synergy_potential": self.calculate_synergy_potential(condition_part, effect_part)
            }
            relations.append(relation)
        
        return relations
    
    def calculate_synergy_potential(self, condition, effect):
        # 计算协同潜力
        condition_type = self.identify_effect_type(condition)
        effect_type = self.identify_effect_type(effect)
        
        # 预定义的协同潜力值
        synergy_matrix = {
            "控制类": {"输出类": 90, "状态类": 75},
            "状态类": {"输出类": 85, "控制类": 70},
            "增益类": {"输出类": 80, "治疗类": 75}
        }
        
        return synergy_matrix.get(condition_type, {}).get(effect_type, 0)
```

### 3.4 协同关系识别模块

#### 3.4.1 协同类型定义
```json
{
  "高协同": [
    {"condition": "控制类", "effect": "输出类", "score": 90},
    {"condition": "状态类", "effect": "输出类", "score": 85},
    {"condition": "增益类", "effect": "输出类", "score": 80}
  ],
  "中协同": [
    {"condition": "控制类", "effect": "状态类", "score": 75},
    {"condition": "状态类", "effect": "控制类", "score": 70},
    {"condition": "治疗类", "effect": "增益类", "score": 70}
  ],
  "低协同": [
    {"condition": "同类效果", "effect": "同类效果", "score": 60}
  ]
}
```

#### 3.4.2 实现方法
```python
class SynergyRelationRecognizer:
    def __init__(self):
        self.synergy_rules = self.load_synergy_rules()
    
    def recognize_synergy_relations(self, skill_effects):
        # 识别战法间的协同关系
        relations = []
        for i, effect1 in enumerate(skill_effects):
            for j, effect2 in enumerate(skill_effects):
                if i != j:
                    synergy = self.calculate_synergy(effect1, effect2)
                    if synergy > 0:
                        relations.append({
                            "skill1": effect1["skill_name"],
                            "skill2": effect2["skill_name"],
                            "synergy_score": synergy,
                            "relation_type": self.classify_synergy(synergy)
                        })
        return relations
    
    def calculate_synergy(self, effect1, effect2):
        # 计算两个效果间的协同值
        condition_type = effect1["type"]
        effect_type = effect2["type"]
        
        for rule in self.synergy_rules["高协同"]:
            if rule["condition"] == condition_type and rule["effect"] == effect_type:
                return rule["score"]
        
        for rule in self.synergy_rules["中协同"]:
            if rule["condition"] == condition_type and rule["effect"] == effect_type:
                return rule["score"]
        
        # 同类效果协同
        if condition_type == effect_type:
            for rule in self.synergy_rules["低协同"]:
                if rule["condition"] == "同类效果":
                    return rule["score"]
        
        return 0
```

### 3.5 协同强度计算模块

#### 3.5.1 计算因素
1. **基础协同值**：基于协同类型的基础评分
2. **效果范围**：单体/群体/全体的影响
3. **触发概率**：效果发动的概率
4. **效果强度**：伤害率、治疗率等数值

#### 3.5.2 实现方法
```python
class SynergyStrengthCalculator:
    def calculate_synergy_strength(self, synergy_relation, skill_data):
        # 计算协同强度
        base_score = synergy_relation["synergy_score"]
        
        # 考虑效果范围
        scope_multiplier = self.get_scope_multiplier(skill_data)
        
        # 考虑触发概率
        probability_multiplier = self.get_probability_multiplier(skill_data)
        
        # 考虑效果强度
        intensity_multiplier = self.get_intensity_multiplier(skill_data)
        
        # 综合计算
        final_score = base_score * scope_multiplier * probability_multiplier * intensity_multiplier
        
        return min(final_score, 100)  # 最高100分
    
    def get_scope_multiplier(self, skill_data):
        # 根据效果范围调整分数
        target_type = skill_data.get("target_type", "单体")
        if target_type == "全体":
            return 1.2
        elif target_type == "群体":
            return 1.1
        else:
            return 1.0
    
    def get_probability_multiplier(self, skill_data):
        # 根据触发概率调整分数
        probability = skill_data.get("probability", "100%")
        prob_value = self.parse_probability(probability)
        return 0.5 + (prob_value / 100) * 0.5  # 0.5-1.0之间
    
    def get_intensity_multiplier(self, skill_data):
        # 根据效果强度调整分数
        damage_rate = skill_data.get("damage_rate", 100)
        return min(damage_rate / 100, 2.0)  # 最高2.0倍
```

### 3.6 队伍协同分析模块

#### 3.6.1 功能描述
分析整个队伍的协同效应，包括：
- 队伍角色完整性评估
- 战法协同关系分析
- 队伍整体协同评分计算
- 改进建议生成

#### 3.6.2 实现方法
```python
class TeamSynergyAnalyzer:
    def analyze_team_synergy(self, team_heroes, data_manager):
        # 分析队伍协同效应
        team_analysis = {
            "team_composition": self.analyze_team_composition(team_heroes),
            "skill_synergies": self.analyze_skill_synergies(team_heroes, data_manager),
            "role_balance": self.evaluate_role_balance(team_heroes),
            "overall_score": 0,
            "recommendations": []
        }
        
        # 计算整体协同评分
        team_analysis["overall_score"] = self.calculate_team_synergy_score(team_analysis)
        
        # 生成改进建议
        team_analysis["recommendations"] = self.generate_recommendations(team_analysis)
        
        return team_analysis
    
    def analyze_team_composition(self, team_heroes):
        # 分析队伍组成
        composition = {
            "heroes": len(team_heroes),
            "roles": [],
            "camp_bonus": self.calculate_camp_bonus(team_heroes),
            "troop_bonus": self.calculate_troop_bonus(team_heroes)
        }
        
        for hero in team_heroes:
            roles = self.identify_hero_roles(hero)
            composition["roles"].extend(roles)
        
        return composition
    
    def analyze_skill_synergies(self, team_heroes, data_manager):
        # 分析队伍中战法的协同关系
        all_skills = []
        for hero in team_heroes:
            main_skill = data_manager.get_skill_details(hero["main_skill"])
            secondary_skill = data_manager.get_skill_details(hero["secondary_skill"])
            all_skills.extend([main_skill, secondary_skill])
        
        synergies = []
        for i, skill1 in enumerate(all_skills):
            for j, skill2 in enumerate(all_skills):
                if i != j:
                    synergy = self.calculate_skill_synergy(skill1, skill2)
                    if synergy > 0:
                        synergies.append({
                            "skill1": skill1["name"],
                            "skill2": skill2["name"],
                            "synergy_score": synergy
                        })
        
        return synergies
```

## 四、协同规则配置

### 4.1 配置文件结构
```json
{
  "synergy_rules": {
    "high_synergy": [
      {"condition": "control", "effect": "damage", "base_score": 90},
      {"condition": "debuff", "effect": "damage", "base_score": 85}
    ],
    "medium_synergy": [
      {"condition": "control", "effect": "debuff", "base_score": 75},
      {"condition": "debuff", "effect": "control", "base_score": 70}
    ],
    "low_synergy": [
      {"condition": "same_type", "effect": "same_type", "base_score": 60}
    ]
  },
  "scoring_factors": {
    "scope_multiplier": {
      "single": 1.0,
      "group": 1.1,
      "all": 1.2
    },
    "probability_multiplier": {
      "min": 0.5,
      "max": 1.0
    }
  }
}
```

### 4.2 动态调整机制
```python
class RuleConfigurator:
    def __init__(self, config_file):
        self.config = self.load_config(config_file)
    
    def update_synergy_rule(self, condition_type, effect_type, new_score):
        # 更新协同规则
        for rule in self.config["synergy_rules"]["high_synergy"]:
            if rule["condition"] == condition_type and rule["effect"] == effect_type:
                rule["base_score"] = new_score
                break
    
    def get_synergy_score(self, condition_type, effect_type):
        # 获取协同评分
        for level in ["high_synergy", "medium_synergy", "low_synergy"]:
            for rule in self.config["synergy_rules"][level]:
                if rule["condition"] == condition_type and rule["effect"] == effect_type:
                    return rule["base_score"]
        return 0
```

## 五、实施计划

### 5.1 第一阶段：基础模块开发
1. 实现文本解析模块
2. 实现关键词识别模块
3. 实现基础的条件效果分析功能

### 5.2 第二阶段：协同分析核心功能
1. 实现协同关系识别模块
2. 实现协同强度计算模块
3. 实现规则配置模块

### 5.3 第三阶段：集成与优化
1. 实现队伍协同分析模块
2. 实现结果输出模块
3. 集成所有模块并进行测试优化

## 六、优势与特点

### 6.1 系统设计优势
1. **数据层纯净**：保持基础数据的原始性和通用性
2. **分析引擎独立**：协同分析功能模块化，便于维护和扩展
3. **规则可配置**：支持动态调整协同规则，适应游戏更新
4. **扩展性强**：易于添加新的协同类型和分析维度

### 6.2 技术实现特点
1. **自然语言处理**：基于文本分析提取协同信息
2. **规则驱动**：通过配置文件管理协同规则
3. **量化评估**：提供可比较的协同强度评分
4. **结构化输出**：生成详细的分析报告和建议